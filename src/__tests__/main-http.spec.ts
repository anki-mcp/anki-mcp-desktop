import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { AppModule } from '../app.module';
import { OriginValidationGuard } from '../http/guards/origin-validation.guard';
import request from 'supertest';

/**
 * Integration tests for HTTP mode server
 *
 * These tests verify that main-http.ts properly:
 * - Creates NestJS HTTP application
 * - Applies security guards
 * - Configures logger correctly
 * - Starts server on specified port
 * - Sets environment variables from CLI options
 */
describe('HTTP Server (main-http integration)', () => {
  let app: INestApplication;

  describe('server configuration', () => {
    beforeEach(async () => {
      // Create test module with HTTP mode
      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule.forHttp()],
      }).compile();

      app = moduleFixture.createNestApplication();
    });

    afterEach(async () => {
      if (app) {
        await app.close();
      }
    });

    it('should create HTTP application', () => {
      expect(app).toBeDefined();
    });

    it('should be able to initialize application', async () => {
      await expect(app.init()).resolves.not.toThrow();
    });

    it('should have OriginValidationGuard class available', () => {
      // Guard class should be defined (it's applied globally in main-http.ts)
      expect(OriginValidationGuard).toBeDefined();
      expect(typeof OriginValidationGuard).toBe('function');
    });
  });

  describe('server startup', () => {
    it('should start on default port 3000', async () => {
      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule.forHttp()],
      }).compile();

      app = moduleFixture.createNestApplication();
      await app.init();
      await app.listen(3000, '127.0.0.1');

      // Server should be listening
      const server = app.getHttpServer();
      expect(server.listening).toBe(true);

      await app.close();
    });

    it('should start on custom port', async () => {
      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule.forHttp()],
      }).compile();

      app = moduleFixture.createNestApplication();
      await app.init();
      await app.listen(8080, '127.0.0.1');

      const server = app.getHttpServer();
      expect(server.listening).toBe(true);

      await app.close();
    });

    it('should bind to specified host', async () => {
      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule.forHttp()],
      }).compile();

      app = moduleFixture.createNestApplication();
      await app.init();
      await app.listen(3001, '0.0.0.0');

      const server = app.getHttpServer();
      expect(server.listening).toBe(true);

      await app.close();
    });
  });

  describe('environment variables', () => {
    const originalEnv = process.env;

    beforeEach(() => {
      process.env = { ...originalEnv };
    });

    afterEach(() => {
      process.env = originalEnv;
    });

    it('should use PORT environment variable', () => {
      process.env.PORT = '8080';

      expect(process.env.PORT).toBe('8080');
    });

    it('should use HOST environment variable', () => {
      process.env.HOST = '0.0.0.0';

      expect(process.env.HOST).toBe('0.0.0.0');
    });

    it('should use ANKI_CONNECT_URL environment variable', () => {
      process.env.ANKI_CONNECT_URL = 'http://192.168.1.100:8765';

      expect(process.env.ANKI_CONNECT_URL).toBe('http://192.168.1.100:8765');
    });
  });

  describe('HTTP endpoints', () => {
    beforeEach(async () => {
      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule.forHttp()],
      }).compile();

      app = moduleFixture.createNestApplication();
      await app.init();
    });

    afterEach(async () => {
      if (app) {
        await app.close();
      }
    });

    it('should respond to health check requests', async () => {
      // Test that server responds to basic HTTP requests
      const response = await request(app.getHttpServer())
        .get('/')
        .expect((res) => {
          // Should get some response (might be 404 or MCP response)
          expect(res.status).toBeDefined();
        });
    });

    it('should have MCP endpoint at root path', async () => {
      // MCP endpoint should be at /
      const response = await request(app.getHttpServer())
        .post('/')
        .set('Content-Type', 'application/json')
        .send({
          jsonrpc: '2.0',
          id: 1,
          method: 'initialize',
          params: {
            protocolVersion: '2025-06-18',
            capabilities: {},
            clientInfo: {
              name: 'test-client',
              version: '1.0.0',
            },
          },
        });

      // Should get a response (success or error, doesn't matter for this test)
      expect(response.status).toBeDefined();
    });
  });

  describe('error handling', () => {
    beforeEach(async () => {
      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule.forHttp()],
      }).compile();

      app = moduleFixture.createNestApplication();
      await app.init();
    });

    afterEach(async () => {
      if (app) {
        await app.close();
      }
    });

    it('should handle malformed requests gracefully', async () => {
      const response = await request(app.getHttpServer())
        .post('/')
        .set('Content-Type', 'application/json')
        .send({ invalid: 'request' });

      // Should not crash, should return some error response
      // Accept any valid HTTP status code
      expect(response.status).toBeDefined();
      expect(response.status).toBeGreaterThanOrEqual(200);
      expect(response.status).toBeLessThan(600);
    });

    it('should handle requests without origin header', async () => {
      // Direct API calls (curl, Postman) don't send Origin header
      const response = await request(app.getHttpServer()).post('/');

      // Should be allowed (OriginValidationGuard allows requests without origin)
      expect(response.status).toBeDefined();
    });
  });

  describe('logger configuration', () => {
    it('should create application with logger for HTTP mode', async () => {
      // This test verifies that the application is configured correctly
      // HTTP mode uses stdout (fd 1) for logging

      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule.forHttp()],
      }).compile();

      app = moduleFixture.createNestApplication();

      // Application should be created with logger configuration
      expect(app).toBeDefined();

      await app.close();
    });
  });

  describe('graceful shutdown', () => {
    it('should close cleanly', async () => {
      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule.forHttp()],
      }).compile();

      app = moduleFixture.createNestApplication();
      await app.init();

      // Should close without errors
      await expect(app.close()).resolves.not.toThrow();
    });

    it('should close after listening', async () => {
      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule.forHttp()],
      }).compile();

      app = moduleFixture.createNestApplication();
      await app.init();
      await app.listen(3002, '127.0.0.1');

      // Should close cleanly even after listening
      await expect(app.close()).resolves.not.toThrow();
    });
  });

  describe('regression: STDIO mode compatibility', () => {
    it('should not break STDIO mode', async () => {
      // Ensure HTTP mode additions don't break STDIO mode
      const moduleFixture: TestingModule = await Test.createTestingModule({
        imports: [AppModule.forStdio()],
      }).compile();

      const stdioApp = moduleFixture.createNestApplication();

      await expect(stdioApp.init()).resolves.not.toThrow();
      await expect(stdioApp.close()).resolves.not.toThrow();
    });
  });
});
